import { messagingApi, validateSignature } from "@line/bot-sdk";
import { CloudflareWorkersAIEmbeddings } from "@langchain/cloudflare";
import { CloudflareVectorizeStore } from "@langchain/cloudflare";
import type { Context } from "hono";
import { processMessageInBackground } from "./background-processor";
import type { CloudflareBindings } from "./types";

/**
 * LINE webhook endpoint handler
 * Processes incoming LINE messages with immediate response and background AI processing
 */
export async function handleWebhook(
	c: Context<{ Bindings: CloudflareBindings }>,
) {
	try {
		// Get request body and headers for signature verification
		const body = await c.req.text();
		const signature = c.req.header("x-line-signature");

		if (!signature) {
			return c.json({ error: "Missing LINE signature" }, 400);
		}

		// Verify LINE webhook signature
		const isValidSignature = validateSignature(
			body,
			c.env.LINE_CHANNEL_SECRET,
			signature,
		);

		if (!isValidSignature) {
			return c.json({ error: "Invalid signature" }, 400);
		}

		const client = new messagingApi.MessagingApiClient({
			channelAccessToken: c.env.LINE_CHANNEL_ACCESS_TOKEN,
		});

		// Parse webhook events
		const events = JSON.parse(body).events;

		for (const event of events) {
			try {
				// === „Ç¢„ÇØ„Çª„ÇπÂà∂Âæ°: Ë®±ÂèØ„Åï„Çå„Åü„Éà„Éº„ÇØ„É´„Éº„É†„ÅÆ„Åø„É°„ÉÉ„Çª„Éº„Ç∏Âá¶ÁêÜ ===
				if (c.env.ALLOWED_TALK_ROOMS) {
					const allowedIds = c.env.ALLOWED_TALK_ROOMS.split(',').map(id => id.trim());
					
					// „ÇΩ„Éº„Çπ„Çø„Ç§„Éó„Å´Âøú„Åò„Å¶ÈÅ©Âàá„Å™ID„ÇíÂèñÂæó
					let sourceId: string | undefined;
					let sourceType: string | undefined;
					
					if (event.source?.type === "user") {
						sourceId = event.source.userId;
						sourceType = "User";
					} else if (event.source?.type === "group") {
						sourceId = event.source.groupId;
						sourceType = "Group";
					} else if (event.source?.type === "room") {
						sourceId = event.source.roomId;
						sourceType = "Room";
					}
					
					if (sourceId && !allowedIds.includes(sourceId)) {
						console.log(`Message access denied for source ID: ${sourceId}. Bot usage restricted to allowed talk rooms only.`);
						console.log(`Source details - Type: ${event.source?.type}, ID: ${sourceId}`);
						
						// „Ç¢„ÇØ„Çª„ÇπÂà∂Èôê„ÅÆÊ°àÂÜÖ„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÈÄÅ‰ø°
						try {
							await client.replyMessage({
								replyToken: event.replyToken,
								messages: [
									{
										type: "text",
										text: `Áî≥„ÅóË®≥„Åî„Åñ„ÅÑ„Åæ„Åõ„Çì„ÄÇ„Åì„ÅÆ„Éú„ÉÉ„Éà„ÅØÁèæÂú®„ÄÅÁâπÂÆö„ÅÆË®±ÂèØ„Åï„Çå„Åü„Éà„Éº„ÇØ„É´„Éº„É†„Åß„ÅÆ„Åø„ÅîÂà©Áî®„ÅÑ„Åü„Å†„Åë„Åæ„Åô„ÄÇüö´\n\n„ÅîÂà©Áî®Â∏åÊúõ„ÅÆÂ†¥Âêà„ÅØ„ÄÅÁÆ°ÁêÜËÄÖ„Å´„ÅäÂïè„ÅÑÂêà„Çè„Åõ„Åè„Å†„Åï„ÅÑ„ÄÇ\n\nüìã ÂèÇËÄÉÊÉÖÂ†±:\nSource Type: ${event.source?.type} (${sourceType})\nSource ID: ${sourceId}\n\nüí° ALLOWED_TALK_ROOMSË®≠ÂÆö„Å´„Åì„ÅÆID„ÇíËøΩÂä†„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ`,
									},
								],
							});
						} catch (replyError) {
							console.error("Failed to send access restriction message:", replyError);
						}
						
						continue;
					}
				}

				if (event.type === "message" && event.message.type === "text") {
					const userMessage = event.message.text;
					const replyToken = event.replyToken;
					
					// „ÇΩ„Éº„Çπ„Çø„Ç§„Éó„Å´Âøú„Åò„Å¶ÈÅ©Âàá„Å™ID„ÇíÂèñÂæóÔºà„É≠„Ç∞Áî®Ôºâ
					const logSourceId = event.source?.type === "user" ? event.source.userId
						: event.source?.type === "group" ? event.source.groupId
						: event.source?.type === "room" ? event.source.roomId
						: "unknown";
					
					// „Éá„Éê„ÉÉ„Ç∞Áî®: ÂÖ®„Å¶„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏„ÅßSourceÊÉÖÂ†±„Çí„É≠„Ç∞Âá∫Âäõ
					console.log(`Message received - Type: ${event.source?.type}, ID: ${logSourceId}, Message: "${userMessage}"`);				// ÁâπÂà•„Ç≥„Éû„É≥„Éâ: ID„ÇíÁ¢∫Ë™ç
				if (userMessage === "/id" || userMessage === "/info" || userMessage === "idÁ¢∫Ë™ç") {
					// Ë©≥Á¥∞„Å™„ÇΩ„Éº„ÇπÊÉÖÂ†±„ÇíÊßãÁØâ
					const sourceInfo = [];
					sourceInfo.push("üìã „Éà„Éº„ÇØ„É´„Éº„É†ÊÉÖÂ†±");
					sourceInfo.push(`\nSource Type: ${event.source?.type}`);
					
					if (event.source?.type === "user") {
						sourceInfo.push(`User ID: ${event.source.userId}`);
						sourceInfo.push(`\nüí° „Ç¢„ÇØ„Çª„ÇπÂà∂Âæ°Áî®ID: ${event.source.userId}`);
					} else if (event.source?.type === "group") {
						sourceInfo.push(`Group ID: ${event.source.groupId}`);
						if (event.source.userId) {
							sourceInfo.push(`Your User ID: ${event.source.userId}`);
						}
						sourceInfo.push(`\nüí° „Ç¢„ÇØ„Çª„ÇπÂà∂Âæ°Áî®ID: ${event.source.groupId}`);
					} else if (event.source?.type === "room") {
						sourceInfo.push(`Room ID: ${event.source.roomId}`);
						if (event.source.userId) {
							sourceInfo.push(`Your User ID: ${event.source.userId}`);
						}
						sourceInfo.push(`\nüí° „Ç¢„ÇØ„Çª„ÇπÂà∂Âæ°Áî®ID: ${event.source.roomId}`);
					}
					
					sourceInfo.push("\n‚Äª „Åì„ÅÆÊÉÖÂ†±„ÅØ„Ç¢„ÇØ„Çª„ÇπÂà∂Âæ°Ë®≠ÂÆö„Åß‰ΩøÁî®„Åß„Åç„Åæ„Åô„ÄÇ");
					
					await client.replyMessage({
						replyToken: replyToken,
						messages: [
							{
								type: "text",
								text: sourceInfo.join(""),
							},
						],
					});
					continue;
					}

					// === Immediate Response Strategy for Cloudflare Workers ===
					// Send immediate acknowledgment and process AI in background
					console.log(`Processing message: "${userMessage}"`);

					// Strategy 1: Fast AI call with aggressive timeout and RAG support
					try {
						// Ultra-fast timeout optimized for Cloudflare Workers
						const AI_TIMEOUT = 4000; // 4 seconds max

						console.log("Sending request to AI...");
						const startTime = Date.now();

						// Try to use RAG for immediate response if available
						let contextualPrompt = userMessage;
						let ragContext = "";

						if (c.env.VECTORIZE) {
							try {
								console.log("Attempting fast RAG search...");

								// Initialize embeddings for the user query
								const embeddings = new CloudflareWorkersAIEmbeddings({
									binding: c.env.AI,
									modelName: "@cf/baai/bge-m3",
								});

								// Initialize vector store for similarity search
								const vectorStore = new CloudflareVectorizeStore(embeddings, {
									index: c.env.VECTORIZE,
								});

								// Quick search for relevant documents (reduced count for speed)
								const results = await vectorStore.similaritySearch(userMessage, 2);

								if (results.length > 0) {
									console.log(`Found ${results.length} relevant documents for fast response`);

									// Prepare context from search results (shorter for fast response)
									ragContext = results
										.map((doc, index) => {
											return `[Èñ¢ÈÄ£ÊÉÖÂ†± ${index + 1}]\n${doc.pageContent.substring(0, 200)}...`;
										})
										.join("\n\n");

									// Create enhanced prompt with context for fast response
									contextualPrompt = `ÈÅéÂéª„ÅÆ‰ºöË©±„Åã„ÇâÈñ¢ÈÄ£ÊÉÖÂ†±„ÇíÂèÇËÄÉ„Å´„Åó„Å¶ÂõûÁ≠î„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ

Èñ¢ÈÄ£ÊÉÖÂ†±:
${ragContext}

Ë≥™Âïè: ${userMessage}

Á∞°ÊΩî„ÅßÁöÑÁ¢∫„Å™ÂõûÁ≠î„Çí„ÅäÈ°ò„ÅÑ„Åó„Åæ„Åô„ÄÇ`;
								}
							} catch (ragError) {
								console.error("Fast RAG search failed:", ragError);
								// Continue with general response if RAG fails
							}
						}

						const aiPromise = c.env.AI.run("@cf/qwen/qwen1.5-0.5b-chat", {
							messages: [
								{
									role: "system",
									content: ragContext
										? "„ÅÇ„Å™„Åü„ÅØË¶™Âàá„Å™AI„Ç¢„Ç∑„Çπ„Çø„É≥„Éà„Åß„Åô„ÄÇÊèê‰æõ„Åï„Çå„ÅüÈñ¢ÈÄ£ÊÉÖÂ†±„ÇíÂèÇËÄÉ„Å´„Åó„Å¶„ÄÅÁ∞°ÊΩî„ÅßÁõ¥Êé•ÁöÑ„Å™Êó•Êú¨Ë™û„ÅÆÂõûÁ≠î„Çí„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ"
										: "„ÅÇ„Å™„Åü„ÅØË¶™Âàá„Å™AI„Ç¢„Ç∑„Çπ„Çø„É≥„Éà„Åß„Åô„ÄÇÁ∞°ÊΩî„ÅßÁõ¥Êé•ÁöÑ„Å™Êó•Êú¨Ë™û„ÅÆÂõûÁ≠î„Çí„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ",
								},
								{
									role: "user",
									content: contextualPrompt,
								},
							],
							max_tokens: 50, // Reduced for speed
							temperature: 0.1, // More deterministic = faster
							stream: false,
						});

						const timeoutPromise = new Promise((_, reject) =>
							setTimeout(() => reject(new Error("AI timeout")), AI_TIMEOUT),
						);

						const aiResponse = await Promise.race([aiPromise, timeoutPromise]);
						const processingTime = Date.now() - startTime;
						console.log(`AI response received in ${processingTime}ms`);

						// Extract response text quickly
						let responseText = "";
						if (aiResponse && typeof aiResponse === "object") {
							const response = aiResponse as Record<string, unknown>;
							responseText =
								(response.response as string) ||
								(response.result as string) ||
								(response.answer as string) ||
								"";
						}

						if (!responseText.trim()) {
							responseText = "„É°„ÉÉ„Çª„Éº„Ç∏„ÇíËÄÉ„Åà„Å¶„ÅÑ„Åæ„Åô...";
						}

						// Add RAG indicator if context was used
						const finalResponse = ragContext 
							? `üìñ ${responseText}`
							: responseText;

						console.log("Sending reply to LINE...");
						await client.replyMessage({
							replyToken: replyToken,
							messages: [
								{
									type: "text",
									text: finalResponse,
								},
							],
						});
						console.log("Reply sent successfully!");

						// Always start background processing for enhanced RAG response
						// This provides a more detailed follow-up even if immediate response succeeded
						// ÈÄÅ‰ø°ÂÖàID„ÇíÈÅ©Âàá„Å´Ê±∫ÂÆö
						const targetId = event.source?.type === "group" ? event.source.groupId
							: event.source?.type === "room" ? event.source.roomId
							: event.source?.userId;
							
						if (targetId) {
							console.log(`Starting background AI processing for enhanced response to ${event.source?.type}: ${targetId}`);
							c.executionCtx.waitUntil(
								processMessageInBackground(
									c.env.AI,
									client,
									targetId,
									userMessage,
									c.env.VECTORIZE, // Pass Vectorize index for RAG support
								),
							);
						}
					} catch (fastAiError) {
						console.error("Fast AI failed:", fastAiError);

						// Strategy 2: Immediate fallback response + background processing
						try {
							const fallbackMessages = [
								"„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÂá¶ÁêÜ‰∏≠„Åß„Åô„ÄÇÂ∞ë„ÄÖ„ÅäÂæÖ„Å°„Åè„Å†„Åï„ÅÑÔºÅ ü§î",
								"ËÄÉ„Åà„Å¶„ÅÑ„Åæ„Åô...Â∞ë„Åó„ÅäÊôÇÈñì„Çí„Åè„Å†„Åï„ÅÑÔºÅ üí≠",
								"AI„Åå„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÂá¶ÁêÜ„Åó„Å¶„ÅÑ„Åæ„Åô... ‚ö°",
								"ÂõûÁ≠î„Çí‰ΩúÊàê‰∏≠„Åß„ÅôÔºÅ üîÑ",
								"„É°„ÉÉ„Çª„Éº„Ç∏„ÇíÂèó‰ø°„Åó„Å¶„ÄÅËÄÉ„Åà„Å¶„ÅÑ„Åæ„ÅôÔºÅ üß†",
							];

							const randomMessage =
								fallbackMessages[
									Math.floor(Math.random() * fallbackMessages.length)
								];

							await client.replyMessage({
								replyToken: replyToken,
								messages: [
									{
										type: "text",
										text: randomMessage,
									},
								],
							});
							console.log("Fallback response sent");

							// Background processing for better AI response (no await)
							// This will run after the webhook response is sent
							// ÈÄÅ‰ø°ÂÖàID„ÇíÈÅ©Âàá„Å´Ê±∫ÂÆö
							const targetId = event.source?.type === "group" ? event.source.groupId
								: event.source?.type === "room" ? event.source.roomId
								: event.source?.userId;
								
							if (targetId) {
								console.log(`Starting background AI processing to ${event.source?.type}: ${targetId}`);
								c.executionCtx.waitUntil(
									processMessageInBackground(
										c.env.AI,
										client,
										targetId,
										userMessage,
										c.env.VECTORIZE, // Pass Vectorize index for RAG support
									),
								);
							}
						} catch (fallbackError) {
							console.error("Fallback response also failed:", fallbackError);
						}
					}
				} else if (event.type === "follow") {
					// Handle follow event (user adds bot as friend)
					// ÂèãÈÅîËøΩÂä†„ÅØË™∞„Åß„ÇÇÂèØËÉΩ - „Ç¢„ÇØ„Çª„ÇπÂà∂Âæ°„Å™„Åó
					await client.replyMessage({
						replyToken: event.replyToken,
						messages: [
							{
								type: "text",
								text: c.env.ALLOWED_TALK_ROOMS 
									? "ÂèãÈÅîËøΩÂä†„ÅÇ„Çä„Åå„Å®„ÅÜ„Åî„Åñ„ÅÑ„Åæ„ÅôÔºÅWorkers AI„ÇíÊê≠Ëºâ„Åó„Åü„ÉÅ„É£„ÉÉ„Éà„Éú„ÉÉ„Éà„Åß„Åô„ÄÇ\n\n‚ö†Ô∏è ÁèæÂú®„ÄÅÁâπÂÆö„ÅÆ„Éà„Éº„ÇØ„É´„Éº„É†„Åß„ÅÆ„Åø„ÅîÂà©Áî®„ÅÑ„Åü„Å†„Åë„Åæ„Åô„ÄÇË®±ÂèØ„Åï„Çå„Åü„Ç∞„É´„Éº„Éó„Åæ„Åü„ÅØ„Éà„Éº„ÇØ„É´„Éº„É†„Åß„ÅäË©±„Åó„Åè„Å†„Åï„ÅÑ„ÄÇü§ñüí¨"
									: "ÂèãÈÅîËøΩÂä†„ÅÇ„Çä„Åå„Å®„ÅÜ„Åî„Åñ„ÅÑ„Åæ„ÅôÔºÅWorkers AI„ÇíÊê≠Ëºâ„Åó„Åü„ÉÅ„É£„ÉÉ„Éà„Éú„ÉÉ„Éà„Åß„Åô„ÄÇ„ÅäÊ∞óËªΩ„Å´„ÅäË©±„Åó„Åè„Å†„Åï„ÅÑÔºÅ ü§ñüí¨",
							},
						],
					});
				} else {
					// Unhandled event type - no action needed
				}
			} catch (eventError) {
				console.error("Error processing event:", eventError);
			}
		}

		return c.json({ status: "OK" });
	} catch (error) {
		console.error("Error in /webhook:", error);
		return c.json({ error: "Internal server error" }, 500);
	}
}
